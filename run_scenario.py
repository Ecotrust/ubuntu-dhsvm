#!/usr/bin/python

import os, sys, getopt, shutil, jinja2, configparser

### turn the config data generated by configparser from the ini file into a dict
def config_to_dict(config):
    nestable_sections = ['meteorology','output', 'soils', 'vegetation']
    outdict = {}
    # import ipdb; ipdb.set_trace()
    for section in config.sections():
        dict_section = '_'.join(section.split(' '))
        if not section in nestable_sections:
            section_dict = {}
            for key in config[section]:
                dict_key = '_'.join(key.split(' '))
                section_dict[dict_key] = config[section][key]
            outdict[dict_section] = section_dict
        else:
            outdict[dict_section] = get_nested_config(config, section)
    return outdict

### configparser does not handle nesting, nor was the original system built for it
###     For the sake of easy templating we're deriving and re-writing using loops
def get_nested_config(config, section):
    # TODO: Do we need an ordered dict to ensure tests pass?
    section_dict = {}
    if section == 'meteorology':
        stations_keys = [
            'Station Name ',
            'North Coordinate ',
            'East Coordinate ',
            'Elevation ',
            'Station File ',
        ]
        section_dict['stations'] = []

        mstf_keys = [
            'MM5 Soil Temperature File ',
        ]
        section_dict['MM5_Soil_Temp_Files'] = []

        keylist_pairs = [
            ('stations', stations_keys),
            ('MM5_Soil_Temp_Files',mstf_keys),
        ]

    elif section == 'output':
        pixel_keys = [
            'North Coordinate ',
            'East Coordinate ',
            'Name            ',
        ]
        section_dict['pixels'] = []

        state_date_keys = [
            'State Date     ',
        ]
        section_dict['state_dates'] = []

        map_variable_keys = [
            'Map Variable ',
            'Map Layer  ',
            'Number of Maps  ',
            'Map Date ',
        ]
        section_dict['map_variables'] = []

        image_variable_keys = [
            'Image Variable ',
            'Image Layer ',
            'Image Start ',
            'Image End ',
            'Image Interval ',
            'Image Upper Limit ',
            'Image Lower Limit '
        ]
        section_dict['image_variables'] = []

        graphics_keys = [
            'Graphics ID ',
        ]
        section_dict['graphics'] = []

        keylist_pairs = [
            ('pixels', pixel_keys),
            ('state_dates',state_date_keys),
            ('map_variables',map_variable_keys),
            ('image_variables',image_variable_keys),
            ('graphics',graphics_keys),
        ]
    elif section == 'soils':
        type_keys = [
            'Soil Description ',
            'Lateral Conductivity ',
            'Exponential Decrease ',
            'Depth Threshold ',
            'Maximum Infiltration ',
            'Capillary Drive ',
            'Surface Albedo ',
            'Number of Soil Layers ',
            'Porosity ',
            'Pore Size Distribution ',
            'Bubbling Pressure ',
            'Field Capacity ',
            'Wilting Point ',
            'Bulk Density ',
            'Vertical Conductivity ',
            'Thermal Conductivity ',
            'Thermal Capacity ',
            'Mannings n ',
        ]
        section_dict['types'] = []

        keylist_pairs = [
            ('types', type_keys),
        ]
    elif section == 'vegetation':
        veg_keys = [
            'Vegetation Description ',
            'Overstory Present ',
            'Understory Present ',
            'Detention Fraction ',
            'Detention Decay ',
            'Fractional Coverage ',
            'Trunk Space ',
            'Aerodynamic Attenuation ',
            'Radiation Attenuation ',
            'Hemi Fract Coverage ',
            'Clumping Factor ',
            'Leaf Angle A ',
            'Leaf Angle B ',
            'Scattering Parameter ',
            'Max Snow Int Capacity ',
            'Mass Release Drip Ratio ',
            'Snow Interception Eff ',
            'Impervious Fraction ',
            'Height ',
            'Maximum Resistance ',
            'Minimum Resistance ',
            'Moisture Threshold ',
            'Vapor Pressure Deficit ',
            'Rpc ',
            'Number of Root Zones ',
            'Root Zone Depths ',
            'Overstory Root Fraction ',
            'Understory Root Fraction ',
            'Overstory Monthly LAI ',
            'Understory Monthly LAI ',
            'Overstory Monthly Alb ',
            'Understory Monthly Alb '
        ]
        section_dict['veg_types'] = []

        keylist_pairs = [
            ('veg_types', veg_keys),
        ]
    else:
        keylist_pairs = []

    for key in config[section]:
        # if any(part in key for part in stations_keys):
        match_found = False
        for (loop_key, keylist) in keylist_pairs:
            for part in keylist:
                if part in key:
                    match_found = True
                    # read these into 'stations' field of dict with both keys and values
                    section_dict[loop_key] += [(key, config[section][key])]
                    break
            if match_found:
                break
        if not match_found:
            dict_key = '_'.join(key.split(' '))
            section_dict[dict_key] = config[section][key]

    return section_dict


def main(argv):
    basin = False
    scenario = False
    root_path = os.path.dirname(os.path.abspath(__file__))
    path = root_path
    help_text = 'usage: run_scenario.py -b <basin dir name> -s <scenario dir name> -p <absolute path to basins dir>'

    REQUIRED_BASIN_INPUT_FILES = [
        'area',
        'constants',
        'meteorology',
        'options',
        'routing',
        'soils',
        'terrain',
    ]

    REQUIRED_SCENARIO_INPUT_FILES = [
        'output',
        'time',
        'vegetation',
    ]

    try:
        opts, args = getopt.getopt(argv,"hb:s:p:",["basin=","scenario=","path="])
    except getopt.GetoptError:
      print(help_text)
      sys.exit(2)
    for (opt, arg) in opts:
        if opt == '-h':
            print(help_text)
            sys.exit()
        elif opt in ("-b", "--basin"):
            basin = arg
        elif opt in ("-s", "--scenario"):
            scenario = arg
        elif opt in ("-p", "--path"):
            path = arg

    # if basin provided, run. Else error
    if not basin:
        if len(args) == 1:
            basin = args[0]
        else:
            print(help_text)
            sys.exit()

    try:
        parent_dir = os.scandir(path)
    except FileNotFoundError as e:
        print("Path not found: %s. Please provide an absolute path to the directory containing your basin directory(ies), or leave blank to use './basins/'" % path )
        sys.exit()

    basin_path = os.path.join(path, basin)
    basin_input_files_dir = os.path.join(basin_path, 'input_files')
    try:
        basin_input_files = os.listdir(basin_input_files_dir)
    except FileNotFoundError as e:
        print("Path not found: %s. Please provide an 'input_files' directory with required input files for your basin." % basin_path )
        sys.exit()

    if not all(x in os.listdir(basin_input_files_dir) for x in REQUIRED_BASIN_INPUT_FILES):
        missing_files = list(set(REQUIRED_BASIN_INPUT_FILES) - set(os.listdir(basin_input_files_dir)))
        print('Error: Your basin is missing the following required basin input files: %s' % ', '.join(missing_files))
        sys.exit()

    # determine scenario name
    scenarios_path = os.path.join(basin_path, 'scenarios')
    try:
        scenarios = os.listdir(scenarios_path)
    except FileNotFoundError as e:
        print("Path not found: %s. Please provide a basin directory with a directory of 'scenarios' in it. " % scenarios_path)
        sys.exit()
    if scenario:
        # if given, test that directory ./basins/basin/scenarios/scenario exists
        if not scenario in scenarios:
            print("Scenario '%s' does not exist in %s. Please check your input." % (scenario, scenarios_path))
            sys.exit()
    else:
        # if no scenario given, collect all (if any) dir names in ./basins/basin/scenarios/
        if len(scenarios) == 1:
            scenario = os.listdir(scenarios_path)[0]
        else:
            #   If more than one - bail, encouraging user to use 'run_basin.py'
            print('Error: It is unclear which scenario you wish to run in %s. Please specify using the `-p` command line argument.' % scenarios_path)
            sys.exit()

    # Test that scenario dir has the required input files
    try:
        scenario_input_files_dir = os.path.join(scenarios_path, scenario, 'input_files')
        scenario_input_files = os.listdir(scenario_input_files_dir)
    except FileNotFoundError as e:
        print("Path not found: %s. Please provide an 'input_files' directory with required input files for your scenario." % os.path.join(scenarios_path, scenario ))
        sys.exit()

    if not all(x in os.listdir(scenario_input_files_dir) for x in REQUIRED_SCENARIO_INPUT_FILES):
        missing_files = list(set(REQUIRED_SCENARIO_INPUT_FILES) - set(os.listdir(scenario_input_files_dir)))
        print('Error: Your scenario is missing the following required scenario input files:')
        print(', '.join(missing_files))
        print("Please add the required files to %s" % scenario_input_files_dir)
        sys.exit()

    # if scenario run dir exists, delete it
    scenario_run_path = os.path.join(scenarios_path,scenario,'run')
    if os.path.exists(scenario_run_path):
        shutil.rmtree(scenario_run_path)

    # create scenario run dir
    try:
        os.mkdir(scenario_run_path)
    except OSError:
        print ("Creation of the directory %s failed" % scenario_run_path)
        sys.exit()

    # create scenario run INPUT
    # TODO: solve for sets of variables that can repeat (soils, weather stations, etc...)
    #       This can be done by overriding templates using jinja2 and blocks...
    runconfig = configparser.ConfigParser()
    runconfig.optionxform=str #enable maintaining case of keys
    for input in REQUIRED_BASIN_INPUT_FILES:
        config_file = os.path.join(basin_input_files_dir, input)
        runconfig.read(config_file)
    for input in REQUIRED_SCENARIO_INPUT_FILES:
        config_file = os.path.join(scenario_input_files_dir, input)
        runconfig.read(config_file)

    # Jinja voodoo
    # file_loader = jinja2.FileSystemLoader('templates')
    file_loader = jinja2.FileSystemLoader(os.path.join(root_path, 'templates'))
    env = jinja2.Environment(loader=file_loader)

    try:
        template = env.get_template(os.path.join('INPUT.basin.run.template'))
    except jinja2.exceptions.TemplateNotFound as e:
        print("PATH: %s" % root_path)
        template = env.get_template(os.path.join('INPUT.basin.run.template'))


    formatted_runconfig = config_to_dict(runconfig)
    output = template.render(formatted_runconfig)
    outfile = os.path.join(scenario_run_path, 'INPUT.%s.%s' % (basin, scenario))
    out_config = open(outfile, "w")
    out_config.write(output)
    out_config.close()

if __name__ == "__main__":
   main(sys.argv[1:])
